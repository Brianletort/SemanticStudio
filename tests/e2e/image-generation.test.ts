import { describe, it, expect, vi, beforeEach } from 'vitest';
import type { ImageGenerationOptions, GeneratedImage } from '@/lib/llm/types';

// Sample base64 encoded image (1x1 transparent PNG for testing)
const MOCK_IMAGE_BASE64 = 'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg==';

// Helper to create async iterable for streaming tests
async function* createStreamingMock(events: unknown[]): AsyncGenerator<unknown, void, unknown> {
  for (const event of events) {
    yield event;
  }
}

// Default streaming events that simulate OpenAI's image streaming API
const defaultStreamingEvents = [
  {
    type: 'image_generation.partial_image',
    partial_image_index: 0,
    b64_json: MOCK_IMAGE_BASE64.substring(0, 50),
  },
  {
    type: 'image_generation.partial_image',
    partial_image_index: 1,
    b64_json: MOCK_IMAGE_BASE64.substring(0, 100),
  },
  {
    type: 'image_generation.completed',
    b64_json: MOCK_IMAGE_BASE64,
    revised_prompt: 'A beautiful streamed image',
  },
];

// Mock functions at module scope
const mockImagesGenerate = vi.fn();
const mockImagesEdit = vi.fn();
const mockFilesCreate = vi.fn();
const mockModelsList = vi.fn();

// Mock OpenAI
vi.mock('openai', () => {
  return {
    default: class MockOpenAI {
      images = {
        generate: mockImagesGenerate,
        edit: mockImagesEdit,
      };
      files = {
        create: mockFilesCreate,
      };
      models = {
        list: mockModelsList,
      };
    },
  };
});

// Mock database
vi.mock('@/lib/db', () => ({
  db: {
    insert: vi.fn().mockReturnValue({
      values: vi.fn().mockReturnValue({
        returning: vi.fn().mockResolvedValue([{ 
          id: 'session-123',
          title: 'Test Session'
        }]),
      }),
    }),
    select: vi.fn().mockReturnValue({
      from: vi.fn().mockReturnValue({
        where: vi.fn().mockReturnValue({
          orderBy: vi.fn().mockResolvedValue([]),
          limit: vi.fn().mockResolvedValue([]),
        }),
        orderBy: vi.fn().mockResolvedValue([]),
      }),
    }),
    update: vi.fn().mockReturnValue({
      set: vi.fn().mockReturnValue({
        where: vi.fn().mockResolvedValue([]),
      }),
    }),
  },
}));

// Import after mocks
import { generateImage, generateImageStream } from '@/lib/llm';
import { OpenAIProvider } from '@/lib/llm/providers/openai';

describe('E2E Image Generation Flow', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    
    // Default mock responses - handle both streaming and non-streaming
    mockImagesGenerate.mockImplementation((params: { stream?: boolean }) => {
      if (params.stream) {
        // Return async iterable for streaming
        return createStreamingMock(defaultStreamingEvents);
      }
      // Return promise for non-streaming
      return Promise.resolve({
        data: [{
          b64_json: MOCK_IMAGE_BASE64,
          revised_prompt: 'A beautiful image generated by AI',
        }],
      });
    });
    
    mockImagesEdit.mockResolvedValue({
      data: [{
        b64_json: MOCK_IMAGE_BASE64,
        revised_prompt: 'An edited image',
      }],
    });
    
    mockFilesCreate.mockResolvedValue({
      id: 'file-test-123',
      purpose: 'vision',
    });
    
    mockModelsList.mockResolvedValue({
      data: [
        { id: 'gpt-5-mini' },
        { id: 'gpt-image-1.5' },
      ],
    });
  });

  describe('Basic Image Generation', () => {
    it('should generate an image from a text prompt', async () => {
      const provider = new OpenAIProvider('test-api-key');
      const prompt = 'a beautiful sunset over mountains';
      
      const result = await provider.generateImage(prompt);
      
      expect(result).toBeDefined();
      expect(result.imageBase64).toBe(MOCK_IMAGE_BASE64);
      expect(result.action).toBe('generate');
    });

    it('should handle different quality levels', async () => {
      const provider = new OpenAIProvider('test-api-key');
      
      // Test low quality
      await provider.generateImage('test', { quality: 'low' });
      expect(mockImagesGenerate).toHaveBeenCalledWith(
        expect.objectContaining({ quality: 'low' })
      );
      
      // Test medium quality
      await provider.generateImage('test', { quality: 'medium' });
      expect(mockImagesGenerate).toHaveBeenCalledWith(
        expect.objectContaining({ quality: 'medium' })
      );
      
      // Test high quality
      await provider.generateImage('test', { quality: 'high' });
      expect(mockImagesGenerate).toHaveBeenCalledWith(
        expect.objectContaining({ quality: 'high' })
      );
    });

    it('should handle different size options', async () => {
      const provider = new OpenAIProvider('test-api-key');
      
      // Test square
      await provider.generateImage('test', { size: '1024x1024' });
      expect(mockImagesGenerate).toHaveBeenCalledWith(
        expect.objectContaining({ size: '1024x1024' })
      );
      
      // Test portrait
      await provider.generateImage('test', { size: '1024x1536' });
      expect(mockImagesGenerate).toHaveBeenCalledWith(
        expect.objectContaining({ size: '1024x1536' })
      );
      
      // Test landscape
      await provider.generateImage('test', { size: '1536x1024' });
      expect(mockImagesGenerate).toHaveBeenCalledWith(
        expect.objectContaining({ size: '1536x1024' })
      );
    });
  });

  describe('Streaming Image Generation', () => {
    it('should yield partial and complete events during generation', async () => {
      const provider = new OpenAIProvider('test-api-key');
      const events: Array<{ type: string; progress?: number; partialImageIndex?: number }> = [];
      
      for await (const event of provider.generateImageStream('test image')) {
        events.push(event);
      }
      
      // Should have partial image events
      const partialEvents = events.filter(e => e.type === 'partial');
      expect(partialEvents.length).toBe(2);
      expect(partialEvents[0].partialImageIndex).toBe(0);
      expect(partialEvents[1].partialImageIndex).toBe(1);
      
      // Should end with a complete event
      const completeEvent = events.find(e => e.type === 'complete');
      expect(completeEvent).toBeDefined();
    });

    it('should handle errors gracefully in stream', async () => {
      const provider = new OpenAIProvider('test-api-key');
      mockImagesGenerate.mockRejectedValueOnce(new Error('API error'));
      
      const events: Array<{ type: string; error?: string }> = [];
      
      for await (const event of provider.generateImageStream('test')) {
        events.push(event);
      }
      
      const errorEvent = events.find(e => e.type === 'error');
      expect(errorEvent).toBeDefined();
      expect(errorEvent?.error).toBe('API error');
    });
  });

  describe('Image Editing', () => {
    it('should edit an existing image based on a prompt', async () => {
      const provider = new OpenAIProvider('test-api-key');
      
      const options: ImageGenerationOptions = {
        action: 'edit',
        inputImages: [{
          type: 'base64',
          value: MOCK_IMAGE_BASE64,
          mimeType: 'image/png',
        }],
      };
      
      const result = await provider.generateImage('add a rainbow', options);
      
      expect(result).toBeDefined();
      expect(result.imageBase64).toBe(MOCK_IMAGE_BASE64);
      expect(result.action).toBe('edit');
    });
  });

  describe('Full Flow Simulation', () => {
    it('should handle a complete image generation workflow', async () => {
      const provider = new OpenAIProvider('test-api-key');
      
      // Step 1: Verify API is available
      const isAvailable = await provider.isAvailable();
      expect(isAvailable).toBe(true);
      
      // Step 2: Generate an image
      const result = await provider.generateImage('a creative logo design', {
        quality: 'high',
        size: '1024x1024',
      });
      
      // Verify result
      expect(result.imageBase64).toBeDefined();
      expect(result.quality).toBe('high');
      expect(result.size).toBe('1024x1024');
      
      // Step 3: The generated image can be used for editing
      const editResult = await provider.generateImage('make it blue', {
        action: 'edit',
        inputImages: [{
          type: 'base64',
          value: result.imageBase64,
          mimeType: 'image/png',
        }],
      });
      
      expect(editResult.imageBase64).toBeDefined();
      expect(editResult.action).toBe('edit');
    });

    it('should handle multiple concurrent image generations', async () => {
      const provider = new OpenAIProvider('test-api-key');
      
      // Generate multiple images concurrently
      const prompts = [
        'a red apple',
        'a blue ocean',
        'a green forest',
      ];
      
      const results = await Promise.all(
        prompts.map(prompt => provider.generateImage(prompt))
      );
      
      expect(results).toHaveLength(3);
      results.forEach(result => {
        expect(result.imageBase64).toBeDefined();
        expect(result.action).toBe('generate');
      });
    });
  });

  describe('Error Handling', () => {
    it('should handle API rate limits', async () => {
      const provider = new OpenAIProvider('test-api-key');
      mockImagesGenerate.mockRejectedValueOnce(new Error('Rate limit exceeded'));
      
      await expect(provider.generateImage('test')).rejects.toThrow('Rate limit exceeded');
    });

    it('should handle network errors', async () => {
      const provider = new OpenAIProvider('test-api-key');
      mockImagesGenerate.mockRejectedValueOnce(new Error('Network error'));
      
      await expect(provider.generateImage('test')).rejects.toThrow('Network error');
    });

    it('should handle invalid responses', async () => {
      const provider = new OpenAIProvider('test-api-key');
      mockImagesGenerate.mockResolvedValueOnce({ data: [] });
      
      await expect(provider.generateImage('test')).rejects.toThrow('No image data returned');
    });
  });

  describe('Provider Capabilities', () => {
    it('should list available models', async () => {
      const provider = new OpenAIProvider('test-api-key');
      
      const models = await provider.listModels();
      
      expect(models).toContain('gpt-5-mini');
      expect(models).toContain('gpt-image-1.5');
    });

    it('should check availability', async () => {
      const provider = new OpenAIProvider('test-api-key');
      
      const available = await provider.isAvailable();
      
      expect(available).toBe(true);
    });
  });
});
